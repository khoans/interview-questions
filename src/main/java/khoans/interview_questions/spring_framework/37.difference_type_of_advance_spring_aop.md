# Difference type of advance Spring AOP
In Spring AOP (Aspect-Oriented Programming), there are several types of advice that can be applied to target methods. These types of advice allow developers to define cross-cutting concerns in a modular way. The main types of advice in Spring AOP are:
1. **Before Advice**: This type of advice is executed before the target method is invoked. It is typically used for tasks such as logging, authentication, or validation.
   ```java
   @Before("execution(* com.example.service.*.*(..))")
   public void beforeAdvice(JoinPoint joinPoint) {
       System.out.println("Before method: " + joinPoint.getSignature().getName());
   }
   ```
2. **After Advice**: This advice is executed after the target method has completed, regardless of whether it completed successfully or threw an exception. It is often used for cleanup tasks.
   ```java
   @After("execution(* com.example.service.*.*(..))")
   public void afterAdvice(JoinPoint joinPoint) {
       System.out.println("After method: " + joinPoint.getSignature().getName());
   }
   ```
3. **After Returning Advice**: This advice is executed only if the target method completes successfully

    ```java
    @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) {
         System.out.println("Method returned: " + result);
    }
    ```
   
4. **After Throwing Advice**: This advice is executed if the target method throws an exception. It is useful for error handling and logging exceptions.
   ```java
   @AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "error")
   public void afterThrowingAdvice(JoinPoint joinPoint, Throwable error) {
       System.out.println("Exception in method: " + joinPoint.getSignature().getName() + " with message: " + error.getMessage());
   }
   ```
5. **Around Advice**: This is the most powerful type of advice, as it allows you to control when the target method is invoked. You can execute code before and after the method execution, and even prevent the method from being called.
   ```java
   @Around("execution(* com.example.service.*.*(..))")
   public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
       System.out.println("Before method: " + joinPoint.getSignature().getName());
       Object result = joinPoint.proceed(); // Proceed to the target method
       System.out.println("After method: " + joinPoint.getSignature().getName());
       return result;
   }
   ```
These types of advice provide a flexible way to implement cross-cutting concerns in a Spring application, allowing for cleaner and more maintainable code.
