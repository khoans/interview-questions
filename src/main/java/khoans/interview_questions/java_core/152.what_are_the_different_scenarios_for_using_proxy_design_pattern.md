# What are the different scenarios for using proxy design pattern?
The Proxy Design Pattern is a structural design pattern that provides a surrogate or placeholder for another object to control access to it. This pattern is useful in various scenarios, including:
1. **Lazy Initialization**: When the creation of an object is resource-intensive or time-consuming, a proxy can be used to delay the creation of the actual object until it is needed. This helps to improve performance and reduce memory usage.

```java

class RealObject {
    public RealObject() {
        // Expensive initialization
    }
    public void performAction() {
        System.out.println("Action performed by RealObject");
    }
}

class ProxyObject {
    private RealObject realObject;
    public void performAction() {
        if (realObject == null) {
            realObject = new RealObject(); // Lazy initialization
        }
        realObject.performAction();
    }
}

// Client code
public class ProxyPatternExample {
    public static void main(String[] args) {
        ProxyObject proxy = new ProxyObject();
        proxy.performAction(); // RealObject is created here
        proxy.performAction(); // RealObject is reused here
    }
}
```
2. **Access Control**: A proxy can be used to control access to an object by implementing security checks or restrictions. For example, a proxy can restrict access to certain methods based on user roles or permissions.

```java

class SecureObject {
    public void sensitiveOperation() {
        System.out.println("Sensitive operation performed");
    }
}

class SecureProxy {
    private SecureObject secureObject = new SecureObject();
    private String userRole;
    public SecureProxy(String userRole) {
        this.userRole = userRole;
    }
    public void sensitiveOperation() {
        if ("ADMIN".equals(userRole)) {
            secureObject.sensitiveOperation();
        } else {
            System.out.println("Access denied: insufficient permissions");
        }
    }
}

// Client code
public class AccessControlProxyExample {
    public static void main(String[] args) {
        SecureProxy adminProxy = new SecureProxy("ADMIN");
        adminProxy.sensitiveOperation(); // Access granted
        SecureProxy userProxy = new SecureProxy("USER");
        userProxy.sensitiveOperation(); // Access denied
    }
}
```
3. **Remote Proxy**: In distributed systems, a remote proxy can be used to represent an object that resides in a different address space (e.g., on a different server). The proxy handles communication with the remote object, allowing clients to interact with it as if it were local.

```java

// Remote Object Interface
interface RemoteService {
    String fetchData();
}

// Remote Object Implementation
class RemoteServiceImpl implements RemoteService {
    public String fetchData() {
        return "Data from remote service";
    }
}

// Remote Proxy
class RemoteServiceProxy implements RemoteService {
    private RemoteService remoteService;
    public RemoteServiceProxy() {
        // In a real scenario, this would involve network communication
        remoteService = new RemoteServiceImpl();
    }
    public String fetchData() {
        return remoteService.fetchData();
    }
}

// Client code
public class RemoteProxyExample {
    public static void main(String[] args) {
        RemoteService remoteProxy = new RemoteServiceProxy();
        System.out.println(remoteProxy.fetchData());
    }
}
```
6. **Virtual Proxy**: A virtual proxy can be used to represent a large object that is expensive to create. The proxy can provide a lightweight representation of the object and only load the full object when necessary.
5. **Caching**: A proxy can be used to cache the results of expensive operations. When a client requests data, the proxy can return the cached result if it is available, reducing the need to perform the operation again.
6. **Logging and Monitoring**: A proxy can be used to log method calls or monitor the performance of an object. The proxy can intercept method calls and record relevant information before delegating the call to the actual object.
7. **Smart Reference**: A proxy can be used to manage the lifecycle of an object, such as reference counting or automatic resource management. The proxy can ensure that the object is properly created and destroyed as needed.
