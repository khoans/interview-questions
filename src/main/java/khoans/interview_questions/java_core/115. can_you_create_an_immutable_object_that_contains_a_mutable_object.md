# Can you create an immutable object that contains a mutable object?
Yes, it is possible to create an immutable object that contains a mutable object by following certain design principles. The key is to ensure that the mutable object is not exposed in a way that allows external modification. Here are some strategies to achieve this:
1. **Defensive Copying**: When returning the mutable object from a getter method, return a copy of the object instead of the original. This prevents external code from modifying the internal state of the immutable object.

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public final class ImmutableContainer {
    private final List<String> mutableList;

    public ImmutableContainer(List<String> list) {
        // Create a defensive copy of the mutable object
        this.mutableList = new ArrayList<>(list);
    }

    // Return an unmodifiable view of the list
    public List<String> getMutableList() {
        return Collections.unmodifiableList(mutableList);
    }
}
```
2. **Encapsulation**: Keep the mutable object private and do not provide any methods that allow modification of it. Only expose methods that return copies or unmodifiable views.
3. **Immutable Wrappers**: Use immutable wrappers around mutable objects. For example, if you have a mutable object, you can create an immutable wrapper class that only exposes read-only methods.
4. **Avoid Direct References**: Do not expose direct references to the mutable object in any way that allows modification. 

By following these strategies, you can create an immutable object that safely contains a mutable object without allowing external modification.
