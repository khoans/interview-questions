# What are the examples of Bridge Design Pattern?
- The Bridge Design Pattern is a structural design pattern that decouples an abstraction from its implementation, allowing the two to vary independently. This pattern is particularly useful when both the abstraction and implementation may change frequently or when you want to avoid a permanent binding between them. Here are some common examples of the Bridge Design Pattern:

1. **Database Connectivity**:
    - The Bridge pattern can be applied to database connectivity where the abstraction represents the database operations (like CRUD operations) and the implementation represents different database systems (like MySQL, PostgreSQL, MongoDB). This allows the application to switch between different databases without changing the core logic.

```java
// Abstraction
interface Database {
    void connect();
    void disconnect();
}

// Implementor
interface DatabaseImplementor {
    void connectImpl();
    void disconnectImpl();
}

// Refined Abstraction
class MySQLDatabase implements Database {
    private DatabaseImplementor implementor;
    public MySQLDatabase(DatabaseImplementor implementor) {
        this.implementor = implementor;
    }
    @Override
    public void connect() {
        implementor.connectImpl();
    }
    @Override
    public void disconnect() {
        implementor.disconnectImpl();
    }
}

// Concrete Implementor
class MySQLImplementor implements DatabaseImplementor {
    @Override
    public void connectImpl() {
        System.out.println("Connecting to MySQL Database");
    }
    @Override
    public void disconnectImpl() {
        System.out.println("Disconnecting from MySQL Database");
    }
}

// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        DatabaseImplementor mysqlImpl = new MySQLImplementor();
        Database mysqlDb = new MySQLDatabase(mysqlImpl);
        mysqlDb.connect();
        mysqlDb.disconnect();
    }
}
```

3. **Remote Control Systems**:

    - In remote control systems, the Bridge pattern can be used to separate the abstraction of the remote control (like TV remote, AC remote) from the implementation of the devices being controlled (like different brands of TVs or ACs). This allows for flexibility in adding new devices without changing the remote control logic.

```java

// Abstraction
interface RemoteControl {
    void turnOn();
    void turnOff();
}

// Implementor
interface Device {
    void powerOn();
    void powerOff();
}

// Refined Abstraction
class TVRemoteControl implements RemoteControl {
    private Device device;
    public TVRemoteControl(Device device) {
        this.device = device;
    }
    @Override
    public void turnOn() {
        device.powerOn();
    }
    @Override
    public void turnOff() {
        device.powerOff();
    }
}

// Concrete Implementor
class SamsungTV implements Device {
    @Override
    public void powerOn() {
        System.out.println("Samsung TV is turned ON");
    }
    @Override
    public void powerOff() {
        System.out.println("Samsung TV is turned OFF");
    }
}
// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        Device samsungTV = new SamsungTV();
        RemoteControl tvRemote = new TVRemoteControl(samsungTV);
        tvRemote.turnOn();
        tvRemote.turnOff();
    }
}
```

4. **File Systems**:

    - The Bridge pattern can be used in file systems where the abstraction represents file operations (like read, write, delete) and the implementation represents different file storage systems (like local file system, cloud storage). This allows for easy switching between different storage systems without changing the file operation logic.

```java

// Abstraction
interface File {
    void read();
    void write();
}

// Implementor
interface FileSystem {
    void readFile();
    void writeFile();
}

// Refined Abstraction
class LocalFile implements File {
    private FileSystem fileSystem;
    public LocalFile(FileSystem fileSystem) {
        this.fileSystem = fileSystem;
    }
    @Override
    public void read() {
        fileSystem.readFile();
    }
    @Override
    public void write() {
        fileSystem.writeFile();
    }
}

// Concrete Implementor
class LocalFileSystem implements FileSystem {
    @Override
    public void readFile() {
        System.out.println("Reading file from Local File System");
    }
    @Override
    public void writeFile() {
        System.out.println("Writing file to Local File System");
    }
}
// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        FileSystem localFS = new LocalFileSystem();
        File localFile = new LocalFile(localFS);
        localFile.read();
        localFile.write();
    }
}
```

5. **Shape Drawing Applications**:

    - In shape drawing applications, the Bridge pattern can be used to separate the abstraction of shapes (like Circle, Square) from their rendering implementations (like VectorRenderer, RasterRenderer). This allows for adding new shapes or rendering methods independently.

```java

// Abstraction
interface Shape {
    void draw();
}

// Implementor
interface Renderer {
    void renderCircle(float radius);
    void renderSquare(float side);
}

// Refined Abstraction
class Circle implements Shape {
    private Renderer renderer;
    private float radius;
    public Circle(Renderer renderer, float radius) {
        this.renderer = renderer;
        this.radius = radius;
    }
    @Override
    public void draw() {
        renderer.renderCircle(radius);
    }
}

// Concrete Implementor
class VectorRenderer implements Renderer {
    @Override
    public void renderCircle(float radius) {
        System.out.println("Drawing Circle with radius " + radius + " using Vector Renderer");
    }
    @Override
    public void renderSquare(float side) {
        System.out.println("Drawing Square with side " + side + " using Vector Renderer");
    }
}

class Square implements Shape {
    private Renderer renderer;
    private float side;
    public Square(Renderer renderer, float side) {
        this.renderer = renderer;
        this.side = side;
    }
    @Override
    public void draw() {
        renderer.renderSquare(side);
    }
}

// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        Renderer vectorRenderer = new VectorRenderer();
        Shape circle = new Circle(vectorRenderer, 5);
        circle.draw();
        
        Renderer squareRenderer = new VectorRenderer();
        Shape square = new Square(squareRenderer, 4);
        square.draw();
    }
}
```
6. **Messaging Systems**:

    - The Bridge pattern can be applied to messaging systems where the abstraction represents message types (like Email, SMS) and the implementation represents different messaging services (like Twilio, SendGrid). This allows for flexibility in adding new messaging services without changing the message type logic.


```java

// Abstraction
interface Message {
    void send(String content);
}
// Implementor
interface MessageService {
    void sendMessage(String content);
}
// Refined Abstraction
class EmailMessage implements Message {
    private MessageService messageService;
    public EmailMessage(MessageService messageService) {
        this.messageService = messageService;
    }
    @Override
    public void send(String content) {
        messageService.sendMessage(content);
    }
}

// Concrete Implementor
class SMTPService implements MessageService {
    @Override
    public void sendMessage(String content) {
        System.out.println("Sending Email via SMTP: " + content);
    }
}

// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        MessageService smtpService = new SMTPService();
        Message emailMessage = new EmailMessage(smtpService);
        emailMessage.send("Hello, this is a test email!");
    }
}
```
7. **Payment Systems**:

    - In payment systems, the Bridge pattern can be used to separate the abstraction of payment methods (like CreditCard, PayPal) from their processing implementations (like Stripe, PayPal API). This allows for easy integration of new payment gateways without changing the payment method logic.

```java

// Abstraction
interface Payment {
    void pay(double amount);
}

// Implementor
interface PaymentProcessor {
    void processPayment(double amount);
}

// Refined Abstraction
class CreditCardPayment implements Payment {
    private PaymentProcessor paymentProcessor;
    public CreditCardPayment(PaymentProcessor paymentProcessor) {
        this.paymentProcessor = paymentProcessor;
    }
    @Override
    public void pay(double amount) {
        paymentProcessor.processPayment(amount);
    }
}

// Concrete Implementor
class StripeProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing credit card payment of $" + amount + " via Stripe");
    }
}
// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        PaymentProcessor stripeProcessor = new StripeProcessor();
        Payment creditCardPayment = new CreditCardPayment(stripeProcessor);
        creditCardPayment.pay(150.00);
    }
}
```

8. **Migrating Legacy Code**:

    - The Bridge pattern can be useful when migrating legacy code to new systems. By separating the abstraction from the implementation, you can gradually replace the implementation without affecting the abstraction, making the migration process smoother.

```java

// Abstraction
interface LegacySystem {
    void performOperation();
}

// Implementor
interface NewSystem {
    void executeOperation();
}

// Refined Abstraction
class LegacyToNewAdapter implements LegacySystem {
    private NewSystem newSystem;
    public LegacyToNewAdapter(NewSystem newSystem) {
        this.newSystem = newSystem;
    }
    @Override
    public void performOperation() {
        newSystem.executeOperation();
    }
}

// Concrete Implementor
class ModernSystem implements NewSystem {
    @Override
    public void executeOperation() {
        System.out.println("Executing operation in the modern system");
    }
}
// Client code
public class BridgePatternExample {
    public static void main(String[] args) {
        NewSystem modernSystem = new ModernSystem();
        LegacySystem legacyAdapter = new LegacyToNewAdapter(modernSystem);
        legacyAdapter.performOperation();
    }
}
```

# What's the difference between Bridge and Adapter Design Patterns?
- The Bridge and Adapter design patterns are both structural patterns that deal with the relationship between abstractions and implementations, but they serve different purposes and are used in different scenarios. Here are the key differences between the two patterns:

1. **Purpose**:
   - **Bridge Pattern**: The Bridge pattern is used to decouple an abstraction from its implementation, allowing both to vary independently. It is intended to provide flexibility and extensibility in the design by separating the abstraction and implementation into different class hierarchies.
   - **Adapter Pattern**: The Adapter pattern is used to convert the interface of a class into another interface that clients expect. It allows incompatible interfaces to work together by wrapping an existing class with a new interface.

2. **When to Use**:
   - **Bridge Pattern**: Use the Bridge pattern when you want to avoid a permanent binding between an abstraction and its implementation, especially when both may change frequently. It is useful when you have multiple implementations of an abstraction.
   - **Adapter Pattern**: Use the Adapter pattern when you have an existing class that does not match the interface you need, and you want to make it compatible without modifying its code. It is often used to integrate legacy code with new systems.
