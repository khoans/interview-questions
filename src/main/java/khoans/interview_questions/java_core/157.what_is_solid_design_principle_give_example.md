# What is SOLID design principle? Give example.

The SOLID design principles are a set of five principles that help software developers create maintainable, flexible,
and scalable software systems. The acronym SOLID stands for:

1. **Single Responsibility Principle (SRP)**: A class should have only one reason to change, meaning it should have only
   one responsibility.

```java
class Student {
    private String name;
    private int age;
    private double grade;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getGrade() {
        return grade;
    }
}

class CalculateStudentGrade {
    public double calculateGrade(Student student) {
        // Grade calculation logic
    }
}

class RankStudent {
    public String rankStudent(Student student) {
        // Student ranking logic
    }
}
   ```

This code violates SRP

```java
class Student {
    private String name;
    private int age;
    private double grade;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getGrade() {
        return grade;
    }

    public double calculateGrade() {
        // Grade calculation logic
    }

    public String rankStudent() {
        // Student ranking logic
    }
}
```

2. **Open/Closed Principle (OCP)**: Software entities (classes, modules, functions) should be open for extension but
   closed for modification. Which means you should be able to add new functionality without changing existing code.

```java

abstract class PaymentMethod {
    public abstract void pay(double amount);
}

class CreditCardPayment extends PaymentMethod {
    @Override
    public void pay(double amount) {
        // Credit card payment logic
    }
}

class PayPalPayment extends PaymentMethod {
    @Override
    public void pay(double amount) {
        // PayPal payment logic
    }
}

class PaymentProcessor {
    public void processPayment(PaymentMethod method, double amount) {
        method.pay(amount);
    }
}
```

this code below violates OCP

```java
class PaymentProcessor {
    public void processPayment(String method, double amount) {
        if (method.equals("CreditCard")) {
            // Credit card payment logic
        }
        else if (method.equals("PayPal")) {
            // PayPal payment logic
        }
    }
}
```

3. **Liskov Substitution Principle (LSP)**: Subtypes must be substitutable for their base types without altering the
   correctness of the program. Which means that objects of a superclass should be replaceable with objects of a subclass
   without affecting the functionality of the program.

```java
   class PaymentProcessor {
    public void processPayment(PaymentMethod method, double amount) {
        method.pay(amount);
    }
}

class PaymentMethod {
    public void pay(double amount) {
        // Default payment logic
    }
}

class CreditCardPayment extends PaymentMethod {
    @Override
    public void pay(double amount) {
        // Credit card payment logic
    }
}

class PayPalPayment extends PaymentMethod {
    @Override
    public void pay(double amount) {
        // PayPal payment logic
    }
}

public static void main(String[] args) {
    PaymentProcessor processor = new PaymentProcessor();
    PaymentMethod creditCard = new CreditCardPayment();
    PaymentMethod paypal = new PayPalPayment();

    processor.processPayment(creditCard, 100.0);
    processor.processPayment(paypal, 200.0);
}
   ```

4. **Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use.
   Instead of one large interface, create smaller, more specific interfaces. Which means that a class should not be
   forced to implement
   methods it does not use.

```java
interface Printer {
    void print(Document doc);
}

interface Scanner {
    void scan(Document doc);
}

class MultiFunctionPrinter implements Printer, Scanner {
    @Override
    public void print(Document doc) {
        // Print logic
    }

    @Override
    public void scan(Document doc) {
        // Scan logic
    }
}
```

This code below violates ISP

```java
interface MultiFunctionDevice {
    void print(Document doc);

    void scan(Document doc);
}

class SimplePrinter implements MultiFunctionDevice {
    @Override
    public void print(Document doc) {
        // Print logic
    }

    @Override
    public void scan(Document doc) {
        throw new UnsupportedOperationException("Scan not supported");
    }
}
```

5. **Dependency Inversion Principle (DIP)**: High-level modules should not depend on low-level modules. Both should
   depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Which means
   that
   you should depend on abstractions (interfaces or abstract classes) rather than concrete implementations.

```java
interface MessageService {
    void sendMessage(String message, String recipient);
}

class EmailService implements MessageService {
    @Override
    public void sendMessage(String message, String recipient) {
        // Email sending logic
    }
}

class SMSService implements MessageService {
    @Override
    public void sendMessage(String message, String recipient) {
        // SMS sending logic
    }
}

class Notification {
    private MessageService messageService;

    public Notification(MessageService messageService) {
        this.messageService = messageService;
    }

    public void notifyUser(String message, String recipient) {
        messageService.sendMessage(message, recipient);
    }
}
```
