# What is the difference between CountDownLatch and CyclicBarrier?
`CountDownLatch` and `CyclicBarrier` are both synchronization aids in Java's `java.util.concurrent` package, but they serve different purposes and have distinct characteristics:
1. **Purpose**:
   - `CountDownLatch`: It is used to make one or more threads wait until a set of operations being performed in other threads completes. It is typically used when you want to wait for a certain number of events to occur before proceeding.
   - `CyclicBarrier`: It is used to make a group of threads wait for each other to reach a common barrier point before proceeding. It is typically used in scenarios where multiple threads need to synchronize at certain points during their execution.
2. **Reusability**:
   - `CountDownLatch`: It is a one-time use synchronization aid. Once the count reaches zero, it cannot be reset or reused. If you need to wait for another set of operations, you must create a new `CountDownLatch` instance.
   - `CyclicBarrier`: It is reusable. After all threads reach the barrier point and are released, the `CyclicBarrier` can be reset and used again for subsequent synchronization points.
3. **Counting Mechanism**:
   - `CountDownLatch`: It is initialized with a count, and each call to `countDown()` decrements the count. When the count reaches zero, all waiting threads are released.
   - `CyclicBarrier`: It is initialized with the number of parties (threads) that must reach the barrier point. When all parties have called `await()`, they are released to continue execution.
4. **Use Cases**:
   - `CountDownLatch`: Commonly used in scenarios such as waiting for multiple worker threads to complete their tasks before proceeding with the main thread.
   - `CyclicBarrier`: Commonly used in scenarios such as parallel computations where multiple threads need to synchronize at certain points, like in iterative algorithms.
Here is a simple example to illustrate the difference:
```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.BrokenBarrierException;
public class SyncAidsExample {
    public static void main(String[] args) throws InterruptedException {
        // Example of CountDownLatch
        int numberOfWorkers = 3;
        CountDownLatch latch = new CountDownLatch(numberOfWorkers);
        
        for (int i = 0; i < numberOfWorkers; i++) {
            final int workerIndex = i;
            new Thread(() -> {
                try {
                    System.out.println("Worker " + workerIndex + " is performing its task.");
                    Thread.sleep(2000);
                    System.out.println("Worker " + workerIndex + " has completed its task.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        System.out.println("Main thread is waiting for workers to complete.");
        latch.await();
        System.out.println("All workers have completed. Main thread is proceeding.");

        // Example of CyclicBarrier
        int numberOfParties = 3;
        CyclicBarrier barrier = new CyclicBarrier(numberOfParties, () -> {
            System.out.println("All parties have reached the barrier. Proceeding...");
        });
        
        for (int i = 0; i < numberOfParties; i++) {
            final int partyIndex = i;
            new Thread(() -> {
                try {
                    System.out.println("Party " + partyIndex + " is performing its task.");
                    Thread.sleep(2000);
                    System.out.println("Party " + partyIndex + " has reached the barrier.");
                    barrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```
In this example, the `CountDownLatch` is used to wait for worker threads to complete their tasks before the main thread proceeds. The `CyclicBarrier` is used to synchronize multiple parties at a barrier point, allowing them to proceed together once all have reached the barrier.
