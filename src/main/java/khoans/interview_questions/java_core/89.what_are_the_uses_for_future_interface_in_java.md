# What are the uses for Future interface in Java?
The `Future` interface in Java is part of the `java.util.concurrent` package and is used to represent the result of an asynchronous computation. It provides a way to retrieve the result of a task that may not have completed yet. Here are some common uses for the `Future` interface in Java:
1. **Asynchronous Task Execution**: The `Future` interface is commonly used in conjunction with the `ExecutorService` to submit tasks for asynchronous execution. When a task is submitted, a `Future` object is returned, which can be used to check the status of the task and retrieve the result once it is completed.
2. **Result Retrieval**: The `Future` interface provides methods such as `get()` to retrieve the result of the computation. If the task is not yet complete, the `get()` method will block until the result is available. There is also an overloaded version of `get(long timeout, TimeUnit unit)` that allows specifying a timeout for waiting.
3. **Task Cancellation**: The `Future` interface provides a `cancel(boolean mayInterruptIfRunning)` method that allows you to cancel the execution of a task. This is useful when you want to stop a long-running task that is no longer needed.
4. **Task Completion Status**: The `Future` interface provides methods such as `isDone()` and `isCancelled()` to check whether the task has completed or has been cancelled. This allows you to monitor the status of the task without blocking.
5. **Handling Exceptions**: When retrieving the result of a task using the `get()` method, if the task encountered an exception during execution, the exception will be wrapped in an `ExecutionException` and thrown. This allows you to handle exceptions that occurred during the asynchronous computation.
Here is a simple example of how to use the `Future` interface in Java:
```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        // Create a thread pool
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        // Create a Callable task
        Callable<Integer> task = () -> {
            // Simulate some computation
            Thread.sleep(2000);
            return 42;
        };

        // Submit the task for execution and get a Future object
        Future<Integer> futureResult = executorService.submit(task);

        try {
            // Retrieve the result of the computation (this will block until the result is available)
            Integer result = futureResult.get();
            System.out.println("The result of the computation is: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            // Shutdown the executor service
            executorService.shutdown();
        }
    }
}
```

In this example, a `Callable` task is submitted to an `ExecutorService`, and a `Future` object is used to retrieve the result of the computation once it is completed.
