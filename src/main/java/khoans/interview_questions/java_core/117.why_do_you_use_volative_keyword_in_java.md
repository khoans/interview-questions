# Why do you use volatile keyword in Java?
The `volatile` keyword in Java is used to indicate that a variable's value may be changed by different threads. It serves as a hint to the Java Virtual Machine (JVM) and the compiler that the variable should not be cached locally by threads, and any read or write operation on the variable should be done directly to and from the main memory.
Here are some reasons why you might use the `volatile` keyword in Java:
1. **Visibility**: When a variable is declared as `volatile`, it ensures that any thread reading the variable will see the most recent write made by any other thread. This is crucial in multi-threaded environments where threads may cache variables locally, leading to stale or inconsistent data.
2. **Atomicity for Single Reads/Writes**: While `volatile` does not provide atomicity for compound actions (like incrementing a variable), it does guarantee atomicity for single read and write operations. This means that when one thread writes to a `volatile` variable, other threads will see the updated value immediately.
3. **Lightweight Synchronization**: Using `volatile` can be a more lightweight alternative to using synchronized blocks or methods when you only need to ensure visibility of a single variable. It can help reduce contention and improve performance in scenarios where full synchronization is not necessary.
4. **Flag Variables**: `volatile` is often used for flag variables that indicate the state of a process, such as a shutdown signal or a completion flag. This allows threads to check the flag without the overhead of synchronization.
5. **Double-Checked Locking**: In certain design patterns, such as the double-checked locking pattern for lazy initialization, `volatile` is used to ensure that the instance variable is correctly published to other threads after it has been initialized.
It's important to note that while `volatile` provides visibility guarantees, it does not replace the need for proper synchronization when dealing with complex operations that involve multiple variables or require atomicity beyond single reads/writes.
Here is a simple example of using the `volatile` keyword in Java:
```java
public class VolatileExample {
    private static volatile boolean running = true;

    public static void main(String[] args) throws InterruptedException {
        Thread workerThread = new Thread(() -> {
            while (running) {
                // Perform some work
            }
            System.out.println("Worker thread stopped.");
        });

        workerThread.start();

        // Let the worker thread run for a while
        Thread.sleep(1000);

        // Stop the worker thread
        running = false;
        workerThread.join();
        System.out.println("Main thread finished.");
    }
}
```
In this example, the `running` variable is declared as `volatile`, ensuring that when the main thread sets it to `false`, the worker thread will see the updated value and stop its execution.
