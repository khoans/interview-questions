# There are two thread T1 and T2, and we want to ensure that these threads run in sequence: T1 followed by T2.

There are several ways to achieve this in Java. Here are a few common approaches:

1. **Using `join()` Method**:
   You can use the `join()` method to make the main thread wait for T1 to finish before starting T2.

   ```java
   public class ThreadSequenceExample {
       public static void main(String[] args) throws InterruptedException {
           Thread t1 = new Thread(() -> {
               System.out.println("Thread T1 is running");
               // Simulate some work with sleep
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println("Thread T1 has finished");
           });

           Thread t2 = new Thread(() -> {
               System.out.println("Thread T2 is running");
           });

           t1.start();
           t1.join(); // Wait for T1 to finish
           t2.start(); // Start T2 after T1 has finished
       }
   }
   ```

2. **Using `CountDownLatch`**:
   You can use a `CountDownLatch` to ensure that T2 waits for T1 to complete before it starts.

    ```java
    import java.util.concurrent.CountDownLatch;
    public class ThreadSequenceExample {
        public static void main(String[] args) {
            CountDownLatch latch = new CountDownLatch(1);

            Thread t1 = new Thread(() -> {
                System.out.println("Thread T1 is running");
                // Simulate some work with sleep
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread T1 has finished");
                latch.countDown(); // Signal that T1 has finished
            });

            Thread t2 = new Thread(() -> {
                try {
                    latch.await(); // Wait for T1 to finish
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread T2 is running");
            });

            t1.start();
            t2.start();
        }
    }
    ```
3. **Using `synchronized` Blocks**: You can use synchronized blocks to control the execution order of the threads.

   ```java
   public class ThreadSequenceExample {
       private static final Object lock = new Object();
       private static boolean isT1Finished = false;

       public static void main(String[] args) {
           Thread t1 = new Thread(() -> {
               synchronized (lock) {
                   System.out.println("Thread T1 is running");
                   // Simulate some work with sleep
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   System.out.println("Thread T1 has finished");
                   isT1Finished = true;
                   lock.notify(); // Notify T2 that T1 has finished
               }
           });

           Thread t2 = new Thread(() -> {
               synchronized (lock) {
                   while (!isT1Finished) {
                       try {
                           lock.wait(); // Wait for T1 to finish
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                       }
                   }
                   System.out.println("Thread T2 is running");
               }
           });

           t1.start();
           t2.start();
       }
   }
   ```
