# What is a CountDownLatch in Java?
A `CountDownLatch` in Java is a synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. It is part of the `java.util.concurrent` package and is implemented in the `CountDownLatch` class. A `CountDownLatch` is initialized with a given count, which represents the number of events or operations that must occur before the waiting threads can proceed.
CountDownLatch is particularly useful in scenarios where you want to ensure that a thread waits for multiple other threads to complete their tasks before continuing its execution. For example, you might use a `CountDownLatch` to wait for several worker threads to finish processing before proceeding with the next step in a workflow.
Here are some key features of `CountDownLatch` in Java:
1. **Initialization**: A `CountDownLatch` is created by specifying an initial count using its constructor. This count represents the number of events that must occur before the latch is released.
2. **Counting Down**: Threads can call the `countDown()` method to decrement the count of the latch. Each call to `countDown()` reduces the count by one.
3. **Waiting**: Threads can call the `await()` method to wait until the count reaches zero. If the count is already zero, the thread proceeds immediately. Otherwise, the thread blocks until the count reaches zero.
4. **One-Time Use**: A `CountDownLatch` can only be used once. Once the count reaches zero, it cannot be reset or reused. If you need a reusable synchronization aid, consider using a `CyclicBarrier` instead.
Here is a simple example of how to use a `CountDownLatch` in Java:
```java
import java.util.concurrent.CountDownLatch;
public class CountDownLatchExample {
    private static final int NUMBER_OF_WORKERS = 3;
    public static void main(String[] args) {
        // Create a CountDownLatch initialized with the number of worker threads
        CountDownLatch latch = new CountDownLatch(NUMBER_OF_WORKERS);
        
        // Create and start worker threads
        for (int i = 0; i < NUMBER_OF_WORKERS; i++) {
            final int workerIndex = i;
            new Thread(() -> {
                try {
                    System.out.println("Worker " + workerIndex + " is performing its task.");
                    // Simulate some work with sleep
                    Thread.sleep(2000);
                    System.out.println("Worker " + workerIndex + " has completed its task.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // Decrement the count of the latch
                    latch.countDown();
                }
            }).start();
        }
        
        try {
            // Main thread waits until all worker threads have completed
            System.out.println("Main thread is waiting for workers to complete.");
            latch.await();
            System.out.println("All workers have completed. Main thread is proceeding.");
        } catch (InterruptedException e) {
            e.printStackTrace();

        }
    }
}
```
In this example, we create a `CountDownLatch` initialized with the number of worker threads. Each worker thread performs its task and calls `countDown()` when it completes. The main thread waits for all worker threads to finish by calling `await()`, and it proceeds only after the count reaches zero.
