# How decorator design pattern different from proxy pattern?

The Decorator Design Pattern and the Proxy Design Pattern are both structural design patterns in software engineering, but they serve different purposes and have distinct characteristics.

1. Purpose:
   - Decorator Pattern: The primary purpose of the Decorator Pattern is to add new functionality or behavior to an object dynamically without altering its structure. It allows for the extension of an object's capabilities by wrapping it with additional layers (decorators).
   - Proxy Pattern: The main purpose of the Proxy Pattern is to provide a surrogate or placeholder for another object to control access to it. Proxies are often used for lazy loading, access control, logging, or caching.

2. Structure:

    - Decorator Pattern: In the Decorator Pattern, both the component (the original object) and the decorators implement the same interface or abstract class. Decorators hold a reference to the component they are decorating and can add behavior before or after delegating calls to the component.
    - Proxy Pattern: In the Proxy Pattern, the proxy class also implements the same interface as the real subject (the original object). The proxy holds a reference to the real subject and controls access to it, often adding additional logic before or after forwarding requests.

3. Use Cases:

    - Decorator Pattern: Use the Decorator Pattern when you want to add responsibilities to individual objects without affecting other objects of the same class. It is useful for scenarios where you need to combine multiple behaviors dynamically.
    - Proxy Pattern: Use the Proxy Pattern when you need to control access to an object, such as implementing lazy initialization, access control, or logging. It is useful when you want to add a layer of indirection to manage how and when the real object is accessed.


Here is a simple example to illustrate the differences between the Decorator and Proxy patterns in Java:
```java
// Component Interface
interface Service {
    void execute();
}
// Concrete Component
class RealService implements Service {
    @Override
    public void execute() {
        System.out.println("Executing Real Service");
    }
}
// Decorator Abstract Class
abstract class ServiceDecorator implements Service {
    protected Service decoratedService;
    public ServiceDecorator(Service service) {
        this.decoratedService = service;
    }
    @Override
    public void execute() {
        decoratedService.execute();
    }
}
// Concrete Decorator - Logging
class LoggingDecorator extends ServiceDecorator {
    public LoggingDecorator(Service service) {
        super(service);
    }
    @Override
    public void execute() {
        System.out.println("Logging before execution");
        super.execute();
        System.out.println("Logging after execution");
    }
}
// Proxy Class
class ServiceProxy implements Service {
    private RealService realService;
    @Override
    public void execute() {
        if (realService == null) {
            realService = new RealService(); // Lazy initialization
        }
        System.out.println("Proxy controlling access");
        realService.execute();
    }
}
// Client Code
public class Main {
    public static void main(String[] args) {
        // Using Decorator
        Service service = new LoggingDecorator(new RealService());
        service.execute();
        // Using Proxy
        Service proxyService = new ServiceProxy();
        proxyService.execute();
    }
}
```
In this example, the `LoggingDecorator` adds logging functionality to the `RealService`, while the `ServiceProxy` controls access to the `RealService` and performs lazy initialization.
