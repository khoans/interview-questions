# When will you use Strategy Design Pattern in Java?
The Strategy Design Pattern is used when you have multiple strategies for a specific behavior.

Here are some scenarios where you might consider using the Strategy Design Pattern in Java:
1. **Multiple Algorithms**: When you have multiple algorithms for a specific task and you want to switch between them at runtime. For example, sorting algorithms (e.g., QuickSort, MergeSort, BubbleSort) can be implemented as different strategies.
2. **Behavioral Variations**: When you have different behaviors that can be applied to an object, and you want to encapsulate these behaviors in separate classes. For example, different payment methods (e.g., CreditCardPayment, PayPalPayment, BankTransferPayment) can be implemented as strategies.
3. **Validation Variations** : When you have different validation rules for input data and you want to apply different validation strategies based on the context. For example, validating user input in different formats (e.g., email, phone number, postal code) can be implemented as strategies.
4. **Dynamic Behavior Changes**: When you want to change the behavior of an object at runtime without modifying its code. The Strategy Pattern allows you to change the strategy being used dynamically.
5. **Open/Closed Principle**: When you want to adhere to the Open/Closed Principle, which states that software entities should be open for extension but closed for modification. By using the Strategy Pattern, you can add new strategies without changing the existing code.
6. **Code Reusability**: When you want to promote code reusability by encapsulating algorithms or behaviors in separate classes that can be reused across different parts of the application.


Here is a simple example of the Strategy Design Pattern in Java:

```java
// Strategy interface
public interface PaymentStrategy {
    void pay(int amount);
}

// Concrete strategy classes
public class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card.");
    }
}

public class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal.");
    }
}

// Context class
public class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}
// Client code
public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.setPaymentStrategy(new CreditCardPayment());
        cart.checkout(100); // Output: Paid 100 using Credit Card.
        cart.setPaymentStrategy(new PayPalPayment());
        cart.checkout(200); // Output: Paid 200 using PayPal.
    }
}
```
