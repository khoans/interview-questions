# Can you explain Decorator Design Pattern with an example?
The Decorator Design Pattern is a structural design pattern that allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. It is often used to adhere to the Single Responsibility Principle by allowing functionality to be divided between classes with unique areas of concern.

The Decorator pattern is like gift-wrapping: you add layers of paper and ribbons around a present without changing what's inside, and you can unwrap or re-wrap it differently anytime.

Here's a simple example to illustrate the Decorator Design Pattern in Java:

```java
// Component Interface
interface Coffee {
    String getDescription();
    double getCost();
}

// Concrete Component
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    @Override
    public double getCost() {
        return 2.0;
    }
}
// Decorator Abstract Class
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
    @Override
    public double getCost() {
        return decoratedCoffee.getCost();
    }
}
// Concrete Decorator - Milk
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Milk";
    }
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.5;
    }
}
// Concrete Decorator - Sugar
class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Sugar";
    }
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.2;
    }
}
// Client Code
public class DecoratorPatternExample {
    public static void main(String[] args) {
        Coffee simpleCoffee = new SimpleCoffee();
        System.out.println(simpleCoffee.getDescription() + " Cost: $" + simpleCoffee.getCost());
        Coffee milkCoffee = new MilkDecorator(simpleCoffee);
        System.out.println(milkCoffee.getDescription() + " Cost: $" + milkCoffee.getCost());
        Coffee sugarMilkCoffee = new SugarDecorator(milkCoffee);
        System.out.println(sugarMilkCoffee.getDescription() + " Cost: $" + sugarMilkCoffee.getCost());
    }
}
```

In this example:
1. We have a `Coffee` interface that defines the methods `getDescription()` and `getCost()`.
2. `SimpleCoffee` is a concrete implementation of the `Coffee` interface.
3. `CoffeeDecorator` is an abstract class that implements the `Coffee` interface and contains a reference to a `Coffee` object.
4. `MilkDecorator` and `SugarDecorator` are concrete decorators that extend `CoffeeDecorator` and add additional functionality (milk and sugar) to the coffee.
5. In the `DecoratorPatternExample` class, we demonstrate how to use the decorators to add milk and sugar to a simple coffee dynamically.
When you run the `DecoratorPatternExample`, the output will be:
6. ```
Simple Coffee Cost: $2.0
Simple Coffee, Milk Cost: $2.5
Simple Coffee, Milk, Sugar Cost: $2.7
```
